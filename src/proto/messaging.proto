syntax = "proto3";

message Signature {
    message ECDSACompact {
        bytes bytes = 1; // compact representation [ R || S ], 64 bytes
        uint32 recovery = 2; // recovery bit
    }
    oneof union {
        ECDSACompact ecdsaCompact = 1;
    }
}

message PublicKey {
    message Secp256k1Uncompresed {
      bytes bytes = 1; // uncompressed point with prefix (0x04) [ P || X || Y ], 65 bytes
    }
    uint64 timestamp = 1;
    optional Signature signature = 2;
    oneof union {
        Secp256k1Uncompresed secp256k1Uncompressed = 3;
    }
}

message PrivateKey {
    message Secp256k1 {
        bytes bytes = 1; // D big-endian, 32 bytes
    }
    uint64 timestamp = 1;
    oneof union {
        Secp256k1 secp256k1 = 2;
    }
    PublicKey publicKey = 3;
}

message Ciphertext {
    message AES256GCM_HKDFSHA256 {
        bytes hkdfSalt = 1;
        bytes gcmNonce = 2;
        // payload MUST contain encoding of a Payload message
        bytes payload = 3;
    }
    oneof union {
        AES256GCM_HKDFSHA256 aes256GcmHkdfSha256 = 1;
    }
}

message PublicKeyBundle {
  PublicKey identityKey = 1;
  PublicKey preKey = 2;
}

message MessageHeader {
  PublicKeyBundle sender = 1;
  PublicKeyBundle recipient = 2;
  uint64 timestamp = 3;
}

message Message {
    bytes headerBytes = 1; // encapsulates the encoded MessageHeader
    Ciphertext ciphertext = 2;
}

// Private Key Storage

message PrivateKeyBundle {
    PrivateKey identityKey = 1;
    repeated PrivateKey preKeys = 2;
}

message EncryptedPrivateKeyBundle {
    bytes walletPreKey = 1;
    Ciphertext ciphertext = 2;
}


// ContentTypeId is used to identify the type of content stored in a Message.
message ContentTypeId {
  string authorityId = 1;  // authority governing this content type
  string typeId = 2;  // type identifier
  uint32 versionMajor = 3; // major version of the type
  uint32 versionMinor = 4; // minor version of the type
}

// EncodedContent is the type embedded in Ciphertext.payload bytes
message EncodedContent {
  // content type identifier used to match the payload with the correct decoding machinery
  ContentTypeId contentType = 1;
  // optional encoding parameters required to correctly decode the content
  map<string, string> contentTypeParams = 2;
  // optional fallback description of the content that can be used in case
  // the client cannot decode or render the content
  optional string contentFallback = 3;
  // encoded content itself
  bytes content = 4;
}

